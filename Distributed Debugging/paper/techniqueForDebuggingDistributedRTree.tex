\section{A Technique for Debugging A Distributed R-Tree}

	Spatial index debugging is a big challenge in a distributed R-Tree and this sections describes a new technique, known as RDebug, which allows debugging the index creation of an R-Tree.
	
	The R-tree index building follows a top-down approach, in other words, the index is always built from root to leaves. Debugging the index reliability as the index is built is a non-trivial task, and the aim of this paper is to show a technique for index debugging after it has been created. Common challenges when working with an R-Tree are: i) Reliability of the nodes replicas of the R-Tree, ii) ensure that the MBR of the parent nodes intersect the MBR of their children, iii) the existence of duplicated nodes or being referenced by more than one parent node, and iv) if the value M and m of the nodes are compliant with the R-Tree descriptions as shown in Section 3,1. Furthermore, it is possible to access index data to help in its optimization as dead space and overlapping area.

	Table 1 shows the RDebug technique for debugging the distributed spatial index, using the index structure itself. The algorithm has two phases:

1) The algorithm processing is similar to the search in an R-Tree;

2) The algorithm does int inverse of a search in an R-Tree appending information to the distributed index.
\begin{lstlisting}[frame=single,caption={RDebug Algorithm}]
Given an R-tree whose node is namely T, the algorithm 
starts on root node

S1 [Search subtrees]
If T is not leaf:
	store the number of entries child
	verifiy the consistency of T in others replicas
	verify the consistency of M and m values
	
	for each entry E in T
		server <- choose one server, randomically,  that store one replica 
				of E
		send msg to server to process the node T 
		child on step S1

If T is leaf
	verifiy the consistency of T in others replicas
	Invoke step S2 [Aggregation]

S2 [Aggregation]
overlap <- calculate overlap area of T
dead_area <- calculate dead area of T
bound <- get the MBR of T
list = {}     //contains the MBRs of entries of T

for each entry E in T
	add the MBR of E in the list
	
If T is not leaf:
    entries_info <- informations of the entries sent by 
    				child node
    bound_child <- bound of the child node
    verify if the bound of the child node is equal to bound 
    of entry of T that points to this child
    count <- retrieve the number of entries child and 
    decrement by 1 unit
    if(count == 0)
        if T has no parent
            send response with R-Tree nodes information to 
            app client
        else
            send msg with child informations to parent node
else
     if T has no parent
            send response with R-Tree nodes information to 
            app client
     else
            send msg with child informations to parent node
\end{lstlisting}
	
	The First Step called of S1 [Search sub-trees], the algorithm traversals every R-Tree node starting from the root node to the leaves. This step objective, beside sparse the debugging algorithm, it is identify consistency issues in the R-Tree nodes and the M and m value consistency.

	The first requisition is sent to a server that stores a replica of the root node, the consistency of the replicas nodes and the M an m values are verified for every node. If the current node T is not a leaf then the number of children is stored to control the number of wanted answers in the second step of the algorithm. For each entry E in the node, a message is sent (to process the step S1) to any server, which contains the replica of the child node of E. If the current node is a leaf, the second step, known as S2 [Aggregation] begins.