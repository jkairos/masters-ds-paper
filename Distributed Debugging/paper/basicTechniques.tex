\section{Related works}
\label{sec:related}

De forma geral, nenhum trabalho foi realizado na proposta de técnicas de depuração do índice R-Tree distribuído, de acordo com nosso conhecimento e observando as revisões de literatura feitas em \cite{manolopoulos2003rth,jacox2007spatial}.
Nosso trabalho propõe um novo algoritmo de depuração do índice R-Tree distribuído e uma plataforma com arquitetura peer-to-peer para processar os algoritmos espaciais distribuídos.

Os trabalhos encontrados na literatura ou propõem técnicas de depuração distribuídas em aplicações genéricas ou propõem técnicas de processamento distribuído da R-Tree. Na Seção \ref{dist_debug} são apresentados os trabalhos que propõem técnicas de depuração distribuída e em \ref{spatialdist} são apresentados as propostas de plataformas para processamento distribuído de algoritmos espaciais.
	
\subsection{Distributed Debugging Techniques}
\label{dist_debug}

In REME-D: a Reflective epidemic Message-Oriented Debugger for Ambient Oriented Applications paper the author breaks down debuggers in two main families (Section 2 - Related Work): log-based debuggers (also known as post-mortem debuggers) and breakpoint-based debuggers (also known as online debuggers).

	Log-based debuggers insert log statements in the code of the program to be able to generate a trace log during its execution.
	
	Breakpoint-based debuggers, on the other hand, execute the program in the debug mode that allows programs to pause/resume the program execution at certain points, inspect program state, and perform step-by-step execution.

	Log-based debuggers insert log statements in the code of the program to able to generate a trace log during its execution. It is the most primitive debugging technique, but it is also the easiest to implement. Indeed, it is often the only technique available, as pointed out by Philip Zeyligger of Cloudera during a Tech Talk in 2013 about Tricks for Distributed Debugging and Diagnosis. In this technique, you insert debugging probes, usually output statements, at carefully selected places in the program. Using output data, you try to understand the execution behavior so you can find bugs. The advantage of this technique are that only simple output statements are required and that you see only the data you select.
	
	However, it has disadvantages. First, you must observe the output of processes on multiple processors at the same time. When the number of processes is large, such observation becomes infeasible. Also, the technique relies completely on your ability to select appropriate places in the program to insert output statements - an inexact art greatly dependent on your experience and thinking. Furthermore, the technique requires modifications to the program and thus may alter the program structure or even introduce new bugs.
	
	Despite its disadvantages, combining output debugging with other techniques can make debugging easier.

	
	Breakpoint-based debuggers, on the other hand, execute the program in the debug mode that allows programs to pause/resume the program execution at certain points, inspect program state, and perform step-by-step execution. Stack traces, for example, give the developer an idea of what has happened before in the execution of the program, giving hints of how the developer got the current point in the execution. Despite the fact that the stack view does not show total causality, in most cases tracing back the stack is enough to find the cause of the bug. When this does not uncover the cause, breakpoints make it easier to mark to interesting places in the execution.
	
	A breakpoint is a point in the execution flow where normal execution is suspended and cluster-state information is saved. At a breakpoint, you can interactively examine and modify parts of cluster states, like execution status and data values, or control later execution by requesting single-step execution or setting further breakpoints. If you request it, execution will continue after the breakpoint.
	
	The technique requires no extra code in the program, so it avoids some of the unwanted effects of adding debugging probes to distributed programs. Also, you can control cluster execution and select display information interactively. The main disadvantage is that you must be knowledgeable enough to set breakpoints at appropriate places in the program and to examine relevant data. Using breakpoints in a distributed environment raises three problems.
	
	First, it is impossible to define a breakpoint in terms of precise global states. Thus, researchers usually define a breakpoint in terms of events in a process or interactions among processes.
	
	Second, the semantics of single-step execution are no longer obvious. Some people define it to be the execution of a single machine instruction or a statement of source code on a local processor. Others consider it to be a single statement on each processor involved. Still others treat an event as a single-step. Executing a single instruction may not be very productive. To find bugs that result from the interaction of processes, it is more effective to run the cluster until a significant event occurs.
	
	Third, there is the problem of halting the process cluster at a breakpoint or after a single step. When a breakpoint is triggered, the whole cluster must be stopped. One simple way to do so is to broadcast pause messages to all processors. A processor completely suspends its execution when it receives the pause message. But in may cases, you want only to stop the process cluster you are interested in, not the entire system. In such cases, you would send out pause messages with a cluster identification. When a processor receives such a message, it suspends only the execution of that cluster's processes. To resume the execution, a continue message is broadcast to all processors.
	
	However, the pause and continue operations are not so simple as they might seem at first. For example, when a process that is subject to a time-out request halts for debugging, the real-time clock is still running. When the process resumes execution, it will encounter a much shorter time-out interval, and its behavior may change significantly. Cooper introduced a logical clock mechanism to maintain correct time-out intervals and this to provide transparent halting [1].
	
	Pause and continue operations also involve the problem of how to halt the cluster in a consistent global state. Chandy and Lamport introduced a distributed algorithm to obtain distributed snapshots of a cluster[2]. The algorithm is intended to capture only global states with stable properties that, once they become true, remain true thereafter (like deadlock and process death).
	
	The algorithm is divided into two independent phases. During the first phase, local state information is recorded at each process. This phase ends when it is determined that all information - both within processes and in transit over communication channels - has been taken into account. In the second phase, the local state information of each process is collected into a snapshot by the processes that initiated the snapshot.
	
	There are two important issues in the use of this algorithm. First, halting a process depends on the interactions between that process and other processes. The algorithm cannot collect local information about a process that has one or no communication channels connected to other processes. Furthermore, consider a process that has only infrequent interactions with other processes: That process would halt long after all other processes have halted. Miller and Choi dealt with this issue by introducing two additional control channels between a debugger process and each process in the cluster [3]. The second issue is that messages must be received in the order in which they are sent. Thus, the algorithm cannot be based directly on a datagram-type communication facility.	
	
\subsection{Distributed Spatial Algorithms}
\label{spatialdist}

Esta Seção apresenta os trabalhos que propõe algoritmo para processar os algoritmos espaciais de forma distribuída.
A primeira publicação encontrada a respeito do tema foi a M-RTree \cite{koudas1996declustering}, que apresenta um servidor master e vários servidores escravos para processar as requisições. Isto gera uma grande concentração
de processamento no servidor mestre, que além de processar alguns níveis diretórios da R-Tree, agrega as respostas para
as aplicações clientes. Estes comportamentos também são evidenciados na MC-RTree \cite{schnitzer1999master}.

Em \cite{an1999storing}, os autores exploram a distribuição de uma árvore R-Tree em
um cluster. O artigo propõe uma arquitetura similar à M-RTree e MC-RTree e, por isso,
possui os mesmos problemas descritos anteriormente.

Na SD-RTree proposta em \cite{du2007sd} uma árvore binária é utilizada ao invés de uma R-Tree.
A árvore binária causa um grande aumento no número de mensagens, já que para o mesmo conjunto de dados a árvore binária possui um número bem maior de níveis que a R-Tree. A proposta Hadoop-GIS \cite{kerr2009alternative} apresenta uma alternativa para processamento paralelo de dados espaciais, mas não emprega índices para melhorar o desempenho das operações nos datasets.

Em \cite{dedsi} é proposta uma plataforma de processamento distribuído de operações espaciais. A arquitetura proposta não é escalável, já que todas as mensagens devem passar por um servidor master replicado. Em [saviosbrc] é proposta uma plataforma com arquitetura peer-to-peer híbrida para processar a junção espacial distribuída. A arquitetura proposta em [saviosbrc] possui um conjunto de servidores centrais para resolução de nomes e gerenciamento de eventos. Estes servidores podem se tornar um gargalo no sistema.

Um framework é proposto em \cite{xie2008two} para realizar o processamento de consultas
espaciais com um esquema de balanceamento de carga em duas fases.
Em \cite{zhang2009spatial} é proposta uma arquitetura que utiliza o modelo MapReduce para
processar as operações espaciais. A arquitetura é indicada, segundo o próprio
trabalho, em casos onde as bases de dados não estão indexadas.
Uma arquitetura utilizando o modelo MapReduce é
apresentada em \cite{zhong2012towards}. A plataforma possui um índice espacial distribuído em dois níveis: índice global
e índice local.

Diferentemente da plataforma DistGeo proposta neste trabalho, nenhum trabalho encontrado na literatura implementou uma plataforma com arquitetura peer-to-peer para processamento de algoritmos espaciais distribuídos. Além disso, nenhum destes trabalhos propõem técnicas para depuração do índice espacial R-Tree de forma distribuída.